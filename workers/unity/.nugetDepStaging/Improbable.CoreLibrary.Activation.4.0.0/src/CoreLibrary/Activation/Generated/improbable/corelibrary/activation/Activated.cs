// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelibrary.activation.ActivatedData in improbable/corelibrary/activation/activated.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Corelibrary.Activation
{
[ReaderInterface]
[CanonicalName("improbable.corelibrary.activation.Activated")]
public interface ActivatedReader : IEntityStateReader
{
    bool IsActive { get; }
    bool ActivateRequested { get; }
    int ActivationCallbacksPending { get; }

    event System.Action<bool> IsActiveUpdated;
    event System.Action<bool> ActivateRequestedUpdated;
    event System.Action<int> ActivationCallbacksPendingUpdated;
}

public interface IActivatedUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    IActivatedUpdater IsActive(bool newValue);
    IActivatedUpdater ActivateRequested(bool newValue);
    IActivatedUpdater ActivationCallbacksPending(int newValue);
}

[WriterInterface]
[CanonicalName("improbable.corelibrary.activation.Activated")]
public interface ActivatedWriter : ActivatedReader, IUpdateable<IActivatedUpdater> { }

public class Activated : global::Improbable.Entity.State.StateBase<Improbable.Corelibrary.Activation.ActivatedData, Schema.Improbable.Corelibrary.Activation.ActivatedData>, ActivatedWriter, IActivatedUpdater
{
    public Activated(global::Improbable.EntityId entityId, Improbable.Corelibrary.Activation.ActivatedData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Corelibrary.Activation.ActivatedDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(Activated));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    public bool IsActive { get { return Data.IsActive; } }
    public bool ActivateRequested { get { return Data.ActivateRequested; } }
    public int ActivationCallbacksPending { get { return Data.ActivationCallbacksPending; } }

    private readonly global::System.Collections.Generic.List<System.Action<bool>> updatedCallbacksIsActive =
        new global::System.Collections.Generic.List<System.Action<bool>>();
    public event System.Action<bool> IsActiveUpdated
    {
        add
        {
            updatedCallbacksIsActive.Add(value);
            value(Data.IsActive);
        }
        remove { updatedCallbacksIsActive.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<bool>> updatedCallbacksActivateRequested =
        new global::System.Collections.Generic.List<System.Action<bool>>();
    public event System.Action<bool> ActivateRequestedUpdated
    {
        add
        {
            updatedCallbacksActivateRequested.Add(value);
            value(Data.ActivateRequested);
        }
        remove { updatedCallbacksActivateRequested.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<int>> updatedCallbacksActivationCallbacksPending =
        new global::System.Collections.Generic.List<System.Action<int>>();
    public event System.Action<int> ActivationCallbacksPendingUpdated
    {
        add
        {
            updatedCallbacksActivationCallbacksPending.Add(value);
            value(Data.ActivationCallbacksPending);
        }
        remove { updatedCallbacksActivationCallbacksPending.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, updatedCallbacksIsActive);
        UnsubscribeEventHandler(visualizer, updatedCallbacksActivateRequested);
        UnsubscribeEventHandler(visualizer, updatedCallbacksActivationCallbacksPending);
    }

    public IActivatedUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new ActivatedUpdate(EntityId, new bool[0], new Schema.Improbable.Corelibrary.Activation.ActivatedData());
            }
            return this;
        }
    }

    IActivatedUpdater IActivatedUpdater.IsActive(bool newValue)
    {
        if (Updater.Proto.IsActiveSpecified || !IsActive.Equals(newValue))
        {
            Updater.Proto.IsActive = newValue;
        }
        return this;
    }

    IActivatedUpdater IActivatedUpdater.ActivateRequested(bool newValue)
    {
        if (Updater.Proto.ActivateRequestedSpecified || !ActivateRequested.Equals(newValue))
        {
            Updater.Proto.ActivateRequested = newValue;
        }
        return this;
    }

    IActivatedUpdater IActivatedUpdater.ActivationCallbacksPending(int newValue)
    {
        if (Updater.Proto.ActivationCallbacksPendingSpecified || !ActivationCallbacksPending.Equals(newValue))
        {
            Updater.Proto.ActivationCallbacksPending = newValue;
        }
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Corelibrary.Activation.ActivatedData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        bool updatedIsActive = update.IsActiveSpecified;
        anythingUpdated |= updatedIsActive;
        if (updatedIsActive) TriggerCallbacks(updatedCallbacksIsActive, Data.IsActive);

        bool updatedActivateRequested = update.ActivateRequestedSpecified;
        anythingUpdated |= updatedActivateRequested;
        if (updatedActivateRequested) TriggerCallbacks(updatedCallbacksActivateRequested, Data.ActivateRequested);

        bool updatedActivationCallbacksPending = update.ActivationCallbacksPendingSpecified;
        anythingUpdated |= updatedActivationCallbacksPending;
        if (updatedActivationCallbacksPending) TriggerCallbacks(updatedCallbacksActivationCallbacksPending, Data.ActivationCallbacksPending);

        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Corelibrary.Activation.ActivatedData stateUpdate)
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }
}

public class ActivatedUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Corelibrary.Activation.ActivatedData, Schema.Improbable.Corelibrary.Activation.ActivatedData>
{
    public const int STATE_UPDATE_FIELD_ID = 190117;
    public ActivatedUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Corelibrary.Activation.ActivatedData proto)
        : base(entityId, statesToClear, Improbable.Corelibrary.Activation.ActivatedDataHelper.Instance, proto, STATE_UPDATE_FIELD_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new Activated(entityId, GetData(), stateSender);
    }

    public static ActivatedUpdate ExtractFrom(global::Improbable.Protocol.StateUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Corelibrary.Activation.ActivatedData>(proto.EntityState, STATE_UPDATE_FIELD_ID);
        return new ActivatedUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), null, protoState);
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = {};
}
}
