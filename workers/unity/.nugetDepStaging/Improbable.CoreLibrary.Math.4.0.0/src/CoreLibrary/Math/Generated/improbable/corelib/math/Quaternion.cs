// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelib.math.Quaternion in improbable/corelib/math/quaternion.proto.

namespace Improbable.Corelib.Math
{
public struct Quaternion : global::System.IEquatable<Quaternion>
{
    public readonly float W;
    public readonly float X;
    public readonly float Y;
    public readonly float Z;

    public Quaternion (float w,
        float x,
        float y,
        float z)
    {
        W = w;
        X = x;
        Y = y;
        Z = z;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is Quaternion))
            return false;
        return Equals((Quaternion) obj);
    }

    public static bool operator ==(Quaternion obj1, Quaternion obj2)
    {
        return obj1.Equals(obj2);
    }

    public static bool operator !=(Quaternion obj1, Quaternion obj2)
    {
        return !obj1.Equals(obj2);
    }

    public bool Equals(Quaternion obj)
    {
        return true
            && W.Equals(obj.W)
            && X.Equals(obj.X)
            && Y.Equals(obj.Y)
            && Z.Equals(obj.Z);
    }

    public override int GetHashCode()
    {
        int res = 1327;
        res = (res * 977) + W.GetHashCode();
        res = (res * 977) + X.GetHashCode();
        res = (res * 977) + Y.GetHashCode();
        res = (res * 977) + Z.GetHashCode();
        return res;
    }
}

//For internal use only, not to be used in user code.
public sealed class QuaternionHelper : global::Improbable.Tools.IProtoConverter<Improbable.Corelib.Math.Quaternion, Schema.Improbable.Corelib.Math.Quaternion>
{
    static readonly QuaternionHelper _instance = new QuaternionHelper();
    public static QuaternionHelper Instance { get { return _instance; } }
    private QuaternionHelper() {}

    public Schema.Improbable.Corelib.Math.Quaternion ToProto(Improbable.Corelib.Math.Quaternion data)
    {
        var proto = new Schema.Improbable.Corelib.Math.Quaternion();
        proto.W = data.W;
        proto.X = data.X;
        proto.Y = data.Y;
        proto.Z = data.Z;
        return proto;
    }

    //Shallow merge method
    public Improbable.Corelib.Math.Quaternion MergeFromProto(Schema.Improbable.Corelib.Math.Quaternion proto, bool[] statesToClear, Improbable.Corelib.Math.Quaternion data)
    {
        return new Improbable.Corelib.Math.Quaternion(
            proto.WSpecified ? proto.W : data.W,
            proto.XSpecified ? proto.X : data.X,
            proto.YSpecified ? proto.Y : data.Y,
            proto.ZSpecified ? proto.Z : data.Z
        );
    }

    public Improbable.Corelib.Math.Quaternion FromProto(Schema.Improbable.Corelib.Math.Quaternion proto)
    {
        return new Improbable.Corelib.Math.Quaternion(
            proto.W,
            proto.X,
            proto.Y,
            proto.Z
        );
    }

    //Shallow merge method
    public void MergeProto(Schema.Improbable.Corelib.Math.Quaternion protoFrom, bool[] statesToClearFrom, Schema.Improbable.Corelib.Math.Quaternion protoTo, bool[] statesToClearTo)
    {
        if (protoFrom.WSpecified)
        {
            protoTo.W = protoFrom.W;
            protoTo.WSpecified = protoFrom.WSpecified;
        }
        if (protoFrom.XSpecified)
        {
            protoTo.X = protoFrom.X;
            protoTo.XSpecified = protoFrom.XSpecified;
        }
        if (protoFrom.YSpecified)
        {
            protoTo.Y = protoFrom.Y;
            protoTo.YSpecified = protoFrom.YSpecified;
        }
        if (protoFrom.ZSpecified)
        {
            protoTo.Z = protoFrom.Z;
            protoTo.ZSpecified = protoFrom.ZSpecified;
        }
    }
}
}
