// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.entity.physical.FreezeConstraints in improbable/entity/physical/freeze_constraints.proto.

namespace Improbable.Entity.Physical
{
public struct FreezeConstraints : global::System.IEquatable<FreezeConstraints>
{
    public readonly bool X;
    public readonly bool Y;
    public readonly bool Z;

    public FreezeConstraints (bool x,
        bool y,
        bool z)
    {
        X = x;
        Y = y;
        Z = z;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is FreezeConstraints))
            return false;
        return Equals((FreezeConstraints) obj);
    }

    public static bool operator ==(FreezeConstraints obj1, FreezeConstraints obj2)
    {
        return obj1.Equals(obj2);
    }

    public static bool operator !=(FreezeConstraints obj1, FreezeConstraints obj2)
    {
        return !obj1.Equals(obj2);
    }

    public bool Equals(FreezeConstraints obj)
    {
        return true
            && X.Equals(obj.X)
            && Y.Equals(obj.Y)
            && Z.Equals(obj.Z);
    }

    public override int GetHashCode()
    {
        int res = 1327;
        res = (res * 977) + X.GetHashCode();
        res = (res * 977) + Y.GetHashCode();
        res = (res * 977) + Z.GetHashCode();
        return res;
    }
}

//For internal use only, not to be used in user code.
public sealed class FreezeConstraintsHelper : global::Improbable.Tools.IProtoConverter<Improbable.Entity.Physical.FreezeConstraints, Schema.Improbable.Entity.Physical.FreezeConstraints>
{
    static readonly FreezeConstraintsHelper _instance = new FreezeConstraintsHelper();
    public static FreezeConstraintsHelper Instance { get { return _instance; } }
    private FreezeConstraintsHelper() {}

    public Schema.Improbable.Entity.Physical.FreezeConstraints ToProto(Improbable.Entity.Physical.FreezeConstraints data)
    {
        var proto = new Schema.Improbable.Entity.Physical.FreezeConstraints();
        proto.X = data.X;
        proto.Y = data.Y;
        proto.Z = data.Z;
        return proto;
    }

    //Shallow merge method
    public Improbable.Entity.Physical.FreezeConstraints MergeFromProto(Schema.Improbable.Entity.Physical.FreezeConstraints proto, bool[] statesToClear, Improbable.Entity.Physical.FreezeConstraints data)
    {
        return new Improbable.Entity.Physical.FreezeConstraints(
            proto.XSpecified ? proto.X : data.X,
            proto.YSpecified ? proto.Y : data.Y,
            proto.ZSpecified ? proto.Z : data.Z
        );
    }

    public Improbable.Entity.Physical.FreezeConstraints FromProto(Schema.Improbable.Entity.Physical.FreezeConstraints proto)
    {
        return new Improbable.Entity.Physical.FreezeConstraints(
            proto.X,
            proto.Y,
            proto.Z
        );
    }

    //Shallow merge method
    public void MergeProto(Schema.Improbable.Entity.Physical.FreezeConstraints protoFrom, bool[] statesToClearFrom, Schema.Improbable.Entity.Physical.FreezeConstraints protoTo, bool[] statesToClearTo)
    {
        if (protoFrom.XSpecified)
        {
            protoTo.X = protoFrom.X;
            protoTo.XSpecified = protoFrom.XSpecified;
        }
        if (protoFrom.YSpecified)
        {
            protoTo.Y = protoFrom.Y;
            protoTo.YSpecified = protoFrom.YSpecified;
        }
        if (protoFrom.ZSpecified)
        {
            protoTo.Z = protoFrom.Z;
            protoTo.ZSpecified = protoFrom.ZSpecified;
        }
    }
}
}
