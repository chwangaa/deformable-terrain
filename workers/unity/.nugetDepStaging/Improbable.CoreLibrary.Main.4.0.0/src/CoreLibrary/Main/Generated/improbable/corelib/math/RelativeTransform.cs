// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelib.math.RelativeTransform in improbable/corelib/math/relative_transform.proto.

namespace Improbable.Corelib.Math
{
public struct RelativeTransform : global::System.IEquatable<RelativeTransform>
{
    public readonly Improbable.Math.Vector3f Position;
    public readonly Improbable.Corelib.Math.Quaternion Rotation;

    public RelativeTransform (Improbable.Math.Vector3f position,
        Improbable.Corelib.Math.Quaternion rotation)
    {
        Position = position;
        Rotation = rotation;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is RelativeTransform))
            return false;
        return Equals((RelativeTransform) obj);
    }

    public static bool operator ==(RelativeTransform obj1, RelativeTransform obj2)
    {
        return obj1.Equals(obj2);
    }

    public static bool operator !=(RelativeTransform obj1, RelativeTransform obj2)
    {
        return !obj1.Equals(obj2);
    }

    public bool Equals(RelativeTransform obj)
    {
        return true
            && Position.Equals(obj.Position)
            && Rotation.Equals(obj.Rotation);
    }

    public override int GetHashCode()
    {
        int res = 1327;
        res = (res * 977) + Position.GetHashCode();
        res = (res * 977) + Rotation.GetHashCode();
        return res;
    }
}

//For internal use only, not to be used in user code.
public sealed class RelativeTransformHelper : global::Improbable.Tools.IProtoConverter<Improbable.Corelib.Math.RelativeTransform, Schema.Improbable.Corelib.Math.RelativeTransform>
{
    static readonly RelativeTransformHelper _instance = new RelativeTransformHelper();
    public static RelativeTransformHelper Instance { get { return _instance; } }
    private RelativeTransformHelper() {}

    public Schema.Improbable.Corelib.Math.RelativeTransform ToProto(Improbable.Corelib.Math.RelativeTransform data)
    {
        var proto = new Schema.Improbable.Corelib.Math.RelativeTransform();
        proto.Position = Improbable.Math.Vector3fHelper.Instance.ToProto(data.Position);
        proto.Rotation = Improbable.Corelib.Math.QuaternionHelper.Instance.ToProto(data.Rotation);
        return proto;
    }

    //Shallow merge method
    public Improbable.Corelib.Math.RelativeTransform MergeFromProto(Schema.Improbable.Corelib.Math.RelativeTransform proto, bool[] statesToClear, Improbable.Corelib.Math.RelativeTransform data)
    {
        return new Improbable.Corelib.Math.RelativeTransform(
            proto.Position != null ? Improbable.Math.Vector3fHelper.Instance.FromProto(proto.Position) : data.Position,
            proto.Rotation != null ? Improbable.Corelib.Math.QuaternionHelper.Instance.FromProto(proto.Rotation) : data.Rotation
        );
    }

    public Improbable.Corelib.Math.RelativeTransform FromProto(Schema.Improbable.Corelib.Math.RelativeTransform proto)
    {
        return new Improbable.Corelib.Math.RelativeTransform(
            Improbable.Math.Vector3fHelper.Instance.FromProto(proto.Position),
            Improbable.Corelib.Math.QuaternionHelper.Instance.FromProto(proto.Rotation)
        );
    }

    //Shallow merge method
    public void MergeProto(Schema.Improbable.Corelib.Math.RelativeTransform protoFrom, bool[] statesToClearFrom, Schema.Improbable.Corelib.Math.RelativeTransform protoTo, bool[] statesToClearTo)
    {
        if (protoFrom.Position != null)
        {
            protoTo.Position = protoFrom.Position;
        }
        if (protoFrom.Rotation != null)
        {
            protoTo.Rotation = protoFrom.Rotation;
        }
    }
}
}
