// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelib.metrics.ClientPhysicsLatencyData in improbable/corelib/metrics/client_physics_latency.proto.

namespace Improbable.Corelib.Metrics
{
public struct ClientPhysicsLatencyData : global::System.IEquatable<ClientPhysicsLatencyData>
{
    public readonly int RoundTripMillis;
    public readonly int RefreshPeriodMillis;

    public ClientPhysicsLatencyData (int roundTripMillis,
        int refreshPeriodMillis)
    {
        RoundTripMillis = roundTripMillis;
        RefreshPeriodMillis = refreshPeriodMillis;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is ClientPhysicsLatencyData))
            return false;
        return Equals((ClientPhysicsLatencyData) obj);
    }

    public static bool operator ==(ClientPhysicsLatencyData obj1, ClientPhysicsLatencyData obj2)
    {
        return obj1.Equals(obj2);
    }

    public static bool operator !=(ClientPhysicsLatencyData obj1, ClientPhysicsLatencyData obj2)
    {
        return !obj1.Equals(obj2);
    }

    public bool Equals(ClientPhysicsLatencyData obj)
    {
        return true
            && RoundTripMillis.Equals(obj.RoundTripMillis)
            && RefreshPeriodMillis.Equals(obj.RefreshPeriodMillis);
    }

    public override int GetHashCode()
    {
        int res = 1327;
        res = (res * 977) + RoundTripMillis.GetHashCode();
        res = (res * 977) + RefreshPeriodMillis.GetHashCode();
        return res;
    }
}

//For internal use only, not to be used in user code.
public sealed class ClientPhysicsLatencyDataHelper : global::Improbable.Tools.IProtoConverter<Improbable.Corelib.Metrics.ClientPhysicsLatencyData, Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData>
{
    static readonly ClientPhysicsLatencyDataHelper _instance = new ClientPhysicsLatencyDataHelper();
    public static ClientPhysicsLatencyDataHelper Instance { get { return _instance; } }
    private ClientPhysicsLatencyDataHelper() {}

    public Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData ToProto(Improbable.Corelib.Metrics.ClientPhysicsLatencyData data)
    {
        var proto = new Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData();
        proto.RoundTripMillis = data.RoundTripMillis;
        proto.RefreshPeriodMillis = data.RefreshPeriodMillis;
        return proto;
    }

    //Shallow merge method
    public Improbable.Corelib.Metrics.ClientPhysicsLatencyData MergeFromProto(Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData proto, bool[] statesToClear, Improbable.Corelib.Metrics.ClientPhysicsLatencyData data)
    {
        return new Improbable.Corelib.Metrics.ClientPhysicsLatencyData(
            proto.RoundTripMillisSpecified ? proto.RoundTripMillis : data.RoundTripMillis,
            proto.RefreshPeriodMillisSpecified ? proto.RefreshPeriodMillis : data.RefreshPeriodMillis
        );
    }

    public Improbable.Corelib.Metrics.ClientPhysicsLatencyData FromProto(Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData proto)
    {
        return new Improbable.Corelib.Metrics.ClientPhysicsLatencyData(
            proto.RoundTripMillis,
            proto.RefreshPeriodMillis
        );
    }

    //Shallow merge method
    public void MergeProto(Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData protoFrom, bool[] statesToClearFrom, Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData protoTo, bool[] statesToClearTo)
    {
        if (protoFrom.RoundTripMillisSpecified)
        {
            protoTo.RoundTripMillis = protoFrom.RoundTripMillis;
            protoTo.RoundTripMillisSpecified = protoFrom.RoundTripMillisSpecified;
        }
        if (protoFrom.RefreshPeriodMillisSpecified)
        {
            protoTo.RefreshPeriodMillis = protoFrom.RefreshPeriodMillis;
            protoTo.RefreshPeriodMillisSpecified = protoFrom.RefreshPeriodMillisSpecified;
        }
        protoTo.ClientPhysicsPingSent.AddRange(protoFrom.ClientPhysicsPingSent);
    }
}
}
