// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelib.slots.FollowingOffsetData in improbable/corelib/slots/following_offset.proto.

namespace Improbable.Corelib.Slots
{
public struct FollowingOffsetData : global::System.IEquatable<FollowingOffsetData>
{
    public readonly Improbable.Math.Vector3d Offset;

    public FollowingOffsetData (Improbable.Math.Vector3d offset)
    {
        Offset = offset;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is FollowingOffsetData))
            return false;
        return Equals((FollowingOffsetData) obj);
    }

    public static bool operator ==(FollowingOffsetData obj1, FollowingOffsetData obj2)
    {
        return obj1.Equals(obj2);
    }

    public static bool operator !=(FollowingOffsetData obj1, FollowingOffsetData obj2)
    {
        return !obj1.Equals(obj2);
    }

    public bool Equals(FollowingOffsetData obj)
    {
        return true
            && Offset.Equals(obj.Offset);
    }

    public override int GetHashCode()
    {
        int res = 1327;
        res = (res * 977) + Offset.GetHashCode();
        return res;
    }
}

//For internal use only, not to be used in user code.
public sealed class FollowingOffsetDataHelper : global::Improbable.Tools.IProtoConverter<Improbable.Corelib.Slots.FollowingOffsetData, Schema.Improbable.Corelib.Slots.FollowingOffsetData>
{
    static readonly FollowingOffsetDataHelper _instance = new FollowingOffsetDataHelper();
    public static FollowingOffsetDataHelper Instance { get { return _instance; } }
    private FollowingOffsetDataHelper() {}

    public Schema.Improbable.Corelib.Slots.FollowingOffsetData ToProto(Improbable.Corelib.Slots.FollowingOffsetData data)
    {
        var proto = new Schema.Improbable.Corelib.Slots.FollowingOffsetData();
        proto.Offset = Improbable.Math.Vector3dHelper.Instance.ToProto(data.Offset);
        return proto;
    }

    //Shallow merge method
    public Improbable.Corelib.Slots.FollowingOffsetData MergeFromProto(Schema.Improbable.Corelib.Slots.FollowingOffsetData proto, bool[] statesToClear, Improbable.Corelib.Slots.FollowingOffsetData data)
    {
        return new Improbable.Corelib.Slots.FollowingOffsetData(
            proto.Offset != null ? Improbable.Math.Vector3dHelper.Instance.FromProto(proto.Offset) : data.Offset
        );
    }

    public Improbable.Corelib.Slots.FollowingOffsetData FromProto(Schema.Improbable.Corelib.Slots.FollowingOffsetData proto)
    {
        return new Improbable.Corelib.Slots.FollowingOffsetData(
            Improbable.Math.Vector3dHelper.Instance.FromProto(proto.Offset)
        );
    }

    //Shallow merge method
    public void MergeProto(Schema.Improbable.Corelib.Slots.FollowingOffsetData protoFrom, bool[] statesToClearFrom, Schema.Improbable.Corelib.Slots.FollowingOffsetData protoTo, bool[] statesToClearTo)
    {
        if (protoFrom.Offset != null)
        {
            protoTo.Offset = protoFrom.Offset;
        }
    }
}
}
