// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelib.physical.GroundedData in improbable/corelib/physical/grounded.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Corelib.Physical
{
[ReaderInterface]
[CanonicalName("improbable.corelib.physical.Grounded")]
public interface GroundedReader : IEntityStateReader
{
    Improbable.EntityId GroundEntityId { get; }
    bool IsGrounded { get; }
    float MaximumInclineDegrees { get; }

    event System.Action<Improbable.EntityId> GroundEntityIdUpdated;
    event System.Action<bool> IsGroundedUpdated;
    event System.Action<float> MaximumInclineDegreesUpdated;
}

public interface IGroundedUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    IGroundedUpdater GroundEntityId(Improbable.EntityId newValue);
    IGroundedUpdater IsGrounded(bool newValue);
    IGroundedUpdater MaximumInclineDegrees(float newValue);
}

[WriterInterface]
[CanonicalName("improbable.corelib.physical.Grounded")]
public interface GroundedWriter : GroundedReader, IUpdateable<IGroundedUpdater> { }

public class Grounded : global::Improbable.Entity.State.StateBase<Improbable.Corelib.Physical.GroundedData, Schema.Improbable.Corelib.Physical.GroundedData>, GroundedWriter, IGroundedUpdater
{
    public Grounded(global::Improbable.EntityId entityId, Improbable.Corelib.Physical.GroundedData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Corelib.Physical.GroundedDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(Grounded));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    public Improbable.EntityId GroundEntityId { get { return Data.GroundEntityId; } }
    public bool IsGrounded { get { return Data.IsGrounded; } }
    public float MaximumInclineDegrees { get { return Data.MaximumInclineDegrees; } }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.EntityId>> updatedCallbacksGroundEntityId =
        new global::System.Collections.Generic.List<System.Action<Improbable.EntityId>>();
    public event System.Action<Improbable.EntityId> GroundEntityIdUpdated
    {
        add
        {
            updatedCallbacksGroundEntityId.Add(value);
            value(Data.GroundEntityId);
        }
        remove { updatedCallbacksGroundEntityId.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<bool>> updatedCallbacksIsGrounded =
        new global::System.Collections.Generic.List<System.Action<bool>>();
    public event System.Action<bool> IsGroundedUpdated
    {
        add
        {
            updatedCallbacksIsGrounded.Add(value);
            value(Data.IsGrounded);
        }
        remove { updatedCallbacksIsGrounded.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<float>> updatedCallbacksMaximumInclineDegrees =
        new global::System.Collections.Generic.List<System.Action<float>>();
    public event System.Action<float> MaximumInclineDegreesUpdated
    {
        add
        {
            updatedCallbacksMaximumInclineDegrees.Add(value);
            value(Data.MaximumInclineDegrees);
        }
        remove { updatedCallbacksMaximumInclineDegrees.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, updatedCallbacksGroundEntityId);
        UnsubscribeEventHandler(visualizer, updatedCallbacksIsGrounded);
        UnsubscribeEventHandler(visualizer, updatedCallbacksMaximumInclineDegrees);
    }

    public IGroundedUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new GroundedUpdate(EntityId, new bool[0], new Schema.Improbable.Corelib.Physical.GroundedData());
            }
            return this;
        }
    }

    IGroundedUpdater IGroundedUpdater.GroundEntityId(Improbable.EntityId newValue)
    {
        if (Updater.Proto.GroundEntityIdSpecified || !GroundEntityId.Equals(newValue))
        {
            Updater.Proto.GroundEntityId = Improbable.EntityIdHelper.Instance.ToProto(newValue);
        }
        return this;
    }

    IGroundedUpdater IGroundedUpdater.IsGrounded(bool newValue)
    {
        if (Updater.Proto.IsGroundedSpecified || !IsGrounded.Equals(newValue))
        {
            Updater.Proto.IsGrounded = newValue;
        }
        return this;
    }

    IGroundedUpdater IGroundedUpdater.MaximumInclineDegrees(float newValue)
    {
        if (Updater.Proto.MaximumInclineDegreesSpecified || !MaximumInclineDegrees.Equals(newValue))
        {
            Updater.Proto.MaximumInclineDegrees = newValue;
        }
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Corelib.Physical.GroundedData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        bool updatedGroundEntityId = update.GroundEntityIdSpecified;
        anythingUpdated |= updatedGroundEntityId;
        if (updatedGroundEntityId) TriggerCallbacks(updatedCallbacksGroundEntityId, Data.GroundEntityId);

        bool updatedIsGrounded = update.IsGroundedSpecified;
        anythingUpdated |= updatedIsGrounded;
        if (updatedIsGrounded) TriggerCallbacks(updatedCallbacksIsGrounded, Data.IsGrounded);

        bool updatedMaximumInclineDegrees = update.MaximumInclineDegreesSpecified;
        anythingUpdated |= updatedMaximumInclineDegrees;
        if (updatedMaximumInclineDegrees) TriggerCallbacks(updatedCallbacksMaximumInclineDegrees, Data.MaximumInclineDegrees);

        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Corelib.Physical.GroundedData stateUpdate)
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }
}

public class GroundedUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Corelib.Physical.GroundedData, Schema.Improbable.Corelib.Physical.GroundedData>
{
    public const int STATE_UPDATE_FIELD_ID = 190104;
    public GroundedUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Corelib.Physical.GroundedData proto)
        : base(entityId, statesToClear, Improbable.Corelib.Physical.GroundedDataHelper.Instance, proto, STATE_UPDATE_FIELD_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new Grounded(entityId, GetData(), stateSender);
    }

    public static GroundedUpdate ExtractFrom(global::Improbable.Protocol.StateUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Corelib.Physical.GroundedData>(proto.EntityState, STATE_UPDATE_FIELD_ID);
        return new GroundedUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), null, protoState);
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = {};
}
}
