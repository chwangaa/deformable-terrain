// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.entity.physical.RigidbodyDataData in improbable/entity/physical/rigidbody_data.proto.

namespace Improbable.Entity.Physical
{
public struct RigidbodyDataData : global::System.IEquatable<RigidbodyDataData>
{
    public readonly float Mass;
    public readonly Improbable.Math.Vector3d Force;
    public readonly Improbable.Math.Vector3d Torque;
    public readonly float Drag;
    public readonly float AngularDrag;
    public readonly Improbable.Entity.Physical.FreezeConstraints FreezePosition;
    public readonly Improbable.Entity.Physical.FreezeConstraints FreezeRotation;
    public readonly bool UseGravity;
    public readonly bool IsKinematic;
    public readonly Improbable.Entity.Physical.RigidbodyDataData.InterpolationMode Interpolation;
    public readonly Improbable.Entity.Physical.RigidbodyDataData.CollisionDetectionMode CollisionDetection;

    public RigidbodyDataData (float mass,
        Improbable.Math.Vector3d force,
        Improbable.Math.Vector3d torque,
        float drag,
        float angularDrag,
        Improbable.Entity.Physical.FreezeConstraints freezePosition,
        Improbable.Entity.Physical.FreezeConstraints freezeRotation,
        bool useGravity,
        bool isKinematic,
        Improbable.Entity.Physical.RigidbodyDataData.InterpolationMode interpolation,
        Improbable.Entity.Physical.RigidbodyDataData.CollisionDetectionMode collisionDetection)
    {
        Mass = mass;
        Force = force;
        Torque = torque;
        Drag = drag;
        AngularDrag = angularDrag;
        FreezePosition = freezePosition;
        FreezeRotation = freezeRotation;
        UseGravity = useGravity;
        IsKinematic = isKinematic;
        Interpolation = interpolation;
        CollisionDetection = collisionDetection;
    }

    public override bool Equals(object obj)
    {
        if (!(obj is RigidbodyDataData))
            return false;
        return Equals((RigidbodyDataData) obj);
    }

    public static bool operator ==(RigidbodyDataData obj1, RigidbodyDataData obj2)
    {
        return obj1.Equals(obj2);
    }

    public static bool operator !=(RigidbodyDataData obj1, RigidbodyDataData obj2)
    {
        return !obj1.Equals(obj2);
    }

    public bool Equals(RigidbodyDataData obj)
    {
        return true
            && Mass.Equals(obj.Mass)
            && Force.Equals(obj.Force)
            && Torque.Equals(obj.Torque)
            && Drag.Equals(obj.Drag)
            && AngularDrag.Equals(obj.AngularDrag)
            && FreezePosition.Equals(obj.FreezePosition)
            && FreezeRotation.Equals(obj.FreezeRotation)
            && UseGravity.Equals(obj.UseGravity)
            && IsKinematic.Equals(obj.IsKinematic)
            && Interpolation.Equals(obj.Interpolation)
            && CollisionDetection.Equals(obj.CollisionDetection);
    }

    public override int GetHashCode()
    {
        int res = 1327;
        res = (res * 977) + Mass.GetHashCode();
        res = (res * 977) + Force.GetHashCode();
        res = (res * 977) + Torque.GetHashCode();
        res = (res * 977) + Drag.GetHashCode();
        res = (res * 977) + AngularDrag.GetHashCode();
        res = (res * 977) + FreezePosition.GetHashCode();
        res = (res * 977) + FreezeRotation.GetHashCode();
        res = (res * 977) + UseGravity.GetHashCode();
        res = (res * 977) + IsKinematic.GetHashCode();
        res = (res * 977) + Interpolation.GetHashCode();
        res = (res * 977) + CollisionDetection.GetHashCode();
        return res;
    }

    public enum CollisionDetectionMode {
        Discrete = 0,
        Continuous = 1,
        Continuousdynamic = 2
    }

    public enum InterpolationMode {
        None = 0,
        Interpolate = 1,
        Extrapolate = 2
    }
}

//For internal use only, not to be used in user code.
public sealed class RigidbodyDataDataHelper : global::Improbable.Tools.IProtoConverter<Improbable.Entity.Physical.RigidbodyDataData, Schema.Improbable.Entity.Physical.RigidbodyDataData>
{
    static readonly RigidbodyDataDataHelper _instance = new RigidbodyDataDataHelper();
    public static RigidbodyDataDataHelper Instance { get { return _instance; } }
    private RigidbodyDataDataHelper() {}

    public Schema.Improbable.Entity.Physical.RigidbodyDataData ToProto(Improbable.Entity.Physical.RigidbodyDataData data)
    {
        var proto = new Schema.Improbable.Entity.Physical.RigidbodyDataData();
        proto.Mass = data.Mass;
        proto.Force = Improbable.Math.Vector3dHelper.Instance.ToProto(data.Force);
        proto.Torque = Improbable.Math.Vector3dHelper.Instance.ToProto(data.Torque);
        proto.Drag = data.Drag;
        proto.AngularDrag = data.AngularDrag;
        proto.FreezePosition = Improbable.Entity.Physical.FreezeConstraintsHelper.Instance.ToProto(data.FreezePosition);
        proto.FreezeRotation = Improbable.Entity.Physical.FreezeConstraintsHelper.Instance.ToProto(data.FreezeRotation);
        proto.UseGravity = data.UseGravity;
        proto.IsKinematic = data.IsKinematic;
        proto.Interpolation = (Schema.Improbable.Entity.Physical.RigidbodyDataData.InterpolationMode) data.Interpolation;
        proto.CollisionDetection = (Schema.Improbable.Entity.Physical.RigidbodyDataData.CollisionDetectionMode) data.CollisionDetection;
        return proto;
    }

    //Shallow merge method
    public Improbable.Entity.Physical.RigidbodyDataData MergeFromProto(Schema.Improbable.Entity.Physical.RigidbodyDataData proto, bool[] statesToClear, Improbable.Entity.Physical.RigidbodyDataData data)
    {
        return new Improbable.Entity.Physical.RigidbodyDataData(
            proto.MassSpecified ? proto.Mass : data.Mass,
            proto.Force != null ? Improbable.Math.Vector3dHelper.Instance.FromProto(proto.Force) : data.Force,
            proto.Torque != null ? Improbable.Math.Vector3dHelper.Instance.FromProto(proto.Torque) : data.Torque,
            proto.DragSpecified ? proto.Drag : data.Drag,
            proto.AngularDragSpecified ? proto.AngularDrag : data.AngularDrag,
            proto.FreezePosition != null ? Improbable.Entity.Physical.FreezeConstraintsHelper.Instance.FromProto(proto.FreezePosition) : data.FreezePosition,
            proto.FreezeRotation != null ? Improbable.Entity.Physical.FreezeConstraintsHelper.Instance.FromProto(proto.FreezeRotation) : data.FreezeRotation,
            proto.UseGravitySpecified ? proto.UseGravity : data.UseGravity,
            proto.IsKinematicSpecified ? proto.IsKinematic : data.IsKinematic,
            proto.InterpolationSpecified ? (Improbable.Entity.Physical.RigidbodyDataData.InterpolationMode) proto.Interpolation : data.Interpolation,
            proto.CollisionDetectionSpecified ? (Improbable.Entity.Physical.RigidbodyDataData.CollisionDetectionMode) proto.CollisionDetection : data.CollisionDetection
        );
    }

    public Improbable.Entity.Physical.RigidbodyDataData FromProto(Schema.Improbable.Entity.Physical.RigidbodyDataData proto)
    {
        return new Improbable.Entity.Physical.RigidbodyDataData(
            proto.Mass,
            Improbable.Math.Vector3dHelper.Instance.FromProto(proto.Force),
            Improbable.Math.Vector3dHelper.Instance.FromProto(proto.Torque),
            proto.Drag,
            proto.AngularDrag,
            Improbable.Entity.Physical.FreezeConstraintsHelper.Instance.FromProto(proto.FreezePosition),
            Improbable.Entity.Physical.FreezeConstraintsHelper.Instance.FromProto(proto.FreezeRotation),
            proto.UseGravity,
            proto.IsKinematic,
            (Improbable.Entity.Physical.RigidbodyDataData.InterpolationMode) proto.Interpolation,
            (Improbable.Entity.Physical.RigidbodyDataData.CollisionDetectionMode) proto.CollisionDetection
        );
    }

    //Shallow merge method
    public void MergeProto(Schema.Improbable.Entity.Physical.RigidbodyDataData protoFrom, bool[] statesToClearFrom, Schema.Improbable.Entity.Physical.RigidbodyDataData protoTo, bool[] statesToClearTo)
    {
        if (protoFrom.MassSpecified)
        {
            protoTo.Mass = protoFrom.Mass;
            protoTo.MassSpecified = protoFrom.MassSpecified;
        }
        if (protoFrom.Force != null)
        {
            protoTo.Force = protoFrom.Force;
        }
        if (protoFrom.Torque != null)
        {
            protoTo.Torque = protoFrom.Torque;
        }
        if (protoFrom.DragSpecified)
        {
            protoTo.Drag = protoFrom.Drag;
            protoTo.DragSpecified = protoFrom.DragSpecified;
        }
        if (protoFrom.AngularDragSpecified)
        {
            protoTo.AngularDrag = protoFrom.AngularDrag;
            protoTo.AngularDragSpecified = protoFrom.AngularDragSpecified;
        }
        if (protoFrom.FreezePosition != null)
        {
            protoTo.FreezePosition = protoFrom.FreezePosition;
        }
        if (protoFrom.FreezeRotation != null)
        {
            protoTo.FreezeRotation = protoFrom.FreezeRotation;
        }
        if (protoFrom.UseGravitySpecified)
        {
            protoTo.UseGravity = protoFrom.UseGravity;
            protoTo.UseGravitySpecified = protoFrom.UseGravitySpecified;
        }
        if (protoFrom.IsKinematicSpecified)
        {
            protoTo.IsKinematic = protoFrom.IsKinematic;
            protoTo.IsKinematicSpecified = protoFrom.IsKinematicSpecified;
        }
        if (protoFrom.InterpolationSpecified)
        {
            protoTo.Interpolation = protoFrom.Interpolation;
            protoTo.InterpolationSpecified = protoFrom.InterpolationSpecified;
        }
        if (protoFrom.CollisionDetectionSpecified)
        {
            protoTo.CollisionDetection = protoFrom.CollisionDetection;
            protoTo.CollisionDetectionSpecified = protoFrom.CollisionDetectionSpecified;
        }
        protoTo.Impulse.AddRange(protoFrom.Impulse);
        protoTo.SetVelocity.AddRange(protoFrom.SetVelocity);
    }
}
}
