// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.corelib.metrics.ClientPhysicsLatencyData in improbable/corelib/metrics/client_physics_latency.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Corelib.Metrics
{
[ReaderInterface]
[CanonicalName("improbable.corelib.metrics.ClientPhysicsLatency")]
public interface ClientPhysicsLatencyReader : IEntityStateReader
{
    int RoundTripMillis { get; }
    int RefreshPeriodMillis { get; }

    event System.Action<int> RoundTripMillisUpdated;
    event System.Action<int> RefreshPeriodMillisUpdated;
    event System.Action<Improbable.Corelib.Metrics.ClientPhysicsPingSent> ClientPhysicsPingSent;
}

public interface IClientPhysicsLatencyUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    IClientPhysicsLatencyUpdater RoundTripMillis(int newValue);
    IClientPhysicsLatencyUpdater RefreshPeriodMillis(int newValue);
    IClientPhysicsLatencyUpdater TriggerClientPhysicsPingSent(
        int timestampMillis);
}

[WriterInterface]
[CanonicalName("improbable.corelib.metrics.ClientPhysicsLatency")]
public interface ClientPhysicsLatencyWriter : ClientPhysicsLatencyReader, IUpdateable<IClientPhysicsLatencyUpdater> { }

public class ClientPhysicsLatency : global::Improbable.Entity.State.StateBase<Improbable.Corelib.Metrics.ClientPhysicsLatencyData, Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData>, ClientPhysicsLatencyWriter, IClientPhysicsLatencyUpdater
{
    public ClientPhysicsLatency(global::Improbable.EntityId entityId, Improbable.Corelib.Metrics.ClientPhysicsLatencyData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Corelib.Metrics.ClientPhysicsLatencyDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(ClientPhysicsLatency));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    public int RoundTripMillis { get { return Data.RoundTripMillis; } }
    public int RefreshPeriodMillis { get { return Data.RefreshPeriodMillis; } }

    private readonly global::System.Collections.Generic.List<System.Action<int>> updatedCallbacksRoundTripMillis =
        new global::System.Collections.Generic.List<System.Action<int>>();
    public event System.Action<int> RoundTripMillisUpdated
    {
        add
        {
            updatedCallbacksRoundTripMillis.Add(value);
            value(Data.RoundTripMillis);
        }
        remove { updatedCallbacksRoundTripMillis.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<int>> updatedCallbacksRefreshPeriodMillis =
        new global::System.Collections.Generic.List<System.Action<int>>();
    public event System.Action<int> RefreshPeriodMillisUpdated
    {
        add
        {
            updatedCallbacksRefreshPeriodMillis.Add(value);
            value(Data.RefreshPeriodMillis);
        }
        remove { updatedCallbacksRefreshPeriodMillis.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Corelib.Metrics.ClientPhysicsPingSent>> eventCallbacksClientPhysicsPingSent =
        new global::System.Collections.Generic.List<System.Action<Improbable.Corelib.Metrics.ClientPhysicsPingSent>>();
    public event System.Action<Improbable.Corelib.Metrics.ClientPhysicsPingSent> ClientPhysicsPingSent
    {
        add { eventCallbacksClientPhysicsPingSent.Add(value); }
        remove { eventCallbacksClientPhysicsPingSent.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, updatedCallbacksRoundTripMillis);
        UnsubscribeEventHandler(visualizer, updatedCallbacksRefreshPeriodMillis);
        UnsubscribeEventHandler(visualizer, eventCallbacksClientPhysicsPingSent);
    }

    public IClientPhysicsLatencyUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new ClientPhysicsLatencyUpdate(EntityId, new bool[0], new Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData());
            }
            return this;
        }
    }

    IClientPhysicsLatencyUpdater IClientPhysicsLatencyUpdater.RoundTripMillis(int newValue)
    {
        if (Updater.Proto.RoundTripMillisSpecified || !RoundTripMillis.Equals(newValue))
        {
            Updater.Proto.RoundTripMillis = newValue;
        }
        return this;
    }

    IClientPhysicsLatencyUpdater IClientPhysicsLatencyUpdater.RefreshPeriodMillis(int newValue)
    {
        if (Updater.Proto.RefreshPeriodMillisSpecified || !RefreshPeriodMillis.Equals(newValue))
        {
            Updater.Proto.RefreshPeriodMillis = newValue;
        }
        return this;
    }

    global::System.Collections.Generic.IList<Improbable.Corelib.Metrics.ClientPhysicsPingSent> triggeredClientPhysicsPingSent = new global::System.Collections.Generic.List<Improbable.Corelib.Metrics.ClientPhysicsPingSent>();
    IClientPhysicsLatencyUpdater IClientPhysicsLatencyUpdater.TriggerClientPhysicsPingSent(
        int timestampMillis)
    {
        var eventData = new Improbable.Corelib.Metrics.ClientPhysicsPingSent(
            timestampMillis);
        triggeredClientPhysicsPingSent.Add(eventData);
        Updater.Proto.ClientPhysicsPingSent.Add(Improbable.Corelib.Metrics.ClientPhysicsPingSentHelper.Instance.ToProto(eventData));
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        bool updatedRoundTripMillis = update.RoundTripMillisSpecified;
        anythingUpdated |= updatedRoundTripMillis;
        if (updatedRoundTripMillis) TriggerCallbacks(updatedCallbacksRoundTripMillis, Data.RoundTripMillis);

        bool updatedRefreshPeriodMillis = update.RefreshPeriodMillisSpecified;
        anythingUpdated |= updatedRefreshPeriodMillis;
        if (updatedRefreshPeriodMillis) TriggerCallbacks(updatedCallbacksRefreshPeriodMillis, Data.RefreshPeriodMillis);

        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData stateUpdate)
    {
        bool anythingUpdated = false;
        bool updatedClientPhysicsPingSent = stateUpdate.ClientPhysicsPingSent.Count > 0;
        TriggerEventCallbacks(eventCallbacksClientPhysicsPingSent, stateUpdate.ClientPhysicsPingSent, Improbable.Corelib.Metrics.ClientPhysicsPingSentHelper.Instance);
        anythingUpdated |= updatedClientPhysicsPingSent;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        bool updatedClientPhysicsPingSent = triggeredClientPhysicsPingSent.Count > 0;
        TriggerEventCallbacks(eventCallbacksClientPhysicsPingSent, triggeredClientPhysicsPingSent);
        if (triggeredClientPhysicsPingSent != null) triggeredClientPhysicsPingSent.Clear();
        anythingUpdated |= updatedClientPhysicsPingSent;
        return anythingUpdated;
    }
}

public class ClientPhysicsLatencyUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Corelib.Metrics.ClientPhysicsLatencyData, Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData>
{
    public const int STATE_UPDATE_FIELD_ID = 190100;
    public ClientPhysicsLatencyUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData proto)
        : base(entityId, statesToClear, Improbable.Corelib.Metrics.ClientPhysicsLatencyDataHelper.Instance, proto, STATE_UPDATE_FIELD_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new ClientPhysicsLatency(entityId, GetData(), stateSender);
    }

    public static ClientPhysicsLatencyUpdate ExtractFrom(global::Improbable.Protocol.StateUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Corelib.Metrics.ClientPhysicsLatencyData>(proto.EntityState, STATE_UPDATE_FIELD_ID);
        return new ClientPhysicsLatencyUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), null, protoState);
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = {};
}
}
