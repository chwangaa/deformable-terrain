// Generated by ProtocGenFabric. DO NOT EDIT!
// source: schema.improbable.entity.physical.CollisionStateData in improbable/entity/physical/collision_state.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Entity.Physical
{
[ReaderInterface]
[CanonicalName("improbable.entity.physical.CollisionState")]
public interface CollisionStateReader : IEntityStateReader
{

    event System.Action<Improbable.Entity.Physical.Collision> Collision;
}

public interface ICollisionStateUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    ICollisionStateUpdater TriggerCollision(
        Improbable.EntityId? entityHit,
        Improbable.Math.Coordinates point,
        Improbable.Math.Vector3d normal,
        Improbable.Math.Vector3d relativeVelocity);
}

[WriterInterface]
[CanonicalName("improbable.entity.physical.CollisionState")]
public interface CollisionStateWriter : CollisionStateReader, IUpdateable<ICollisionStateUpdater> { }

public class CollisionState : global::Improbable.Entity.State.StateBase<Improbable.Entity.Physical.CollisionStateData, Schema.Improbable.Entity.Physical.CollisionStateData>, CollisionStateWriter, ICollisionStateUpdater
{
    public CollisionState(global::Improbable.EntityId entityId, Improbable.Entity.Physical.CollisionStateData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Entity.Physical.CollisionStateDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(CollisionState));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    
    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Entity.Physical.Collision>> eventCallbacksCollision =
        new global::System.Collections.Generic.List<System.Action<Improbable.Entity.Physical.Collision>>();
    public event System.Action<Improbable.Entity.Physical.Collision> Collision
    {
        add { eventCallbacksCollision.Add(value); }
        remove { eventCallbacksCollision.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, eventCallbacksCollision);
    }

    public ICollisionStateUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new CollisionStateUpdate(EntityId, new bool[0], new Schema.Improbable.Entity.Physical.CollisionStateData());
            }
            return this;
        }
    }

    global::System.Collections.Generic.IList<Improbable.Entity.Physical.Collision> triggeredCollision = new global::System.Collections.Generic.List<Improbable.Entity.Physical.Collision>();
    ICollisionStateUpdater ICollisionStateUpdater.TriggerCollision(
        Improbable.EntityId? entityHit,
        Improbable.Math.Coordinates point,
        Improbable.Math.Vector3d normal,
        Improbable.Math.Vector3d relativeVelocity)
    {
        var eventData = new Improbable.Entity.Physical.Collision(
            entityHit,
            point,
            normal,
            relativeVelocity);
        triggeredCollision.Add(eventData);
        Updater.Proto.Collision.Add(Improbable.Entity.Physical.CollisionHelper.Instance.ToProto(eventData));
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Entity.Physical.CollisionStateData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Entity.Physical.CollisionStateData stateUpdate)
    {
        bool anythingUpdated = false;
        bool updatedCollision = stateUpdate.Collision.Count > 0;
        TriggerEventCallbacks(eventCallbacksCollision, stateUpdate.Collision, Improbable.Entity.Physical.CollisionHelper.Instance);
        anythingUpdated |= updatedCollision;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        bool updatedCollision = triggeredCollision.Count > 0;
        TriggerEventCallbacks(eventCallbacksCollision, triggeredCollision);
        if (triggeredCollision != null) triggeredCollision.Clear();
        anythingUpdated |= updatedCollision;
        return anythingUpdated;
    }
}

public class CollisionStateUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Entity.Physical.CollisionStateData, Schema.Improbable.Entity.Physical.CollisionStateData>
{
    public const int STATE_UPDATE_FIELD_ID = 190119;
    public CollisionStateUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Entity.Physical.CollisionStateData proto)
        : base(entityId, statesToClear, Improbable.Entity.Physical.CollisionStateDataHelper.Instance, proto, STATE_UPDATE_FIELD_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new CollisionState(entityId, GetData(), stateSender);
    }

    public static CollisionStateUpdate ExtractFrom(global::Improbable.Protocol.StateUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Entity.Physical.CollisionStateData>(proto.EntityState, STATE_UPDATE_FIELD_ID);
        return new CollisionStateUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), null, protoState);
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = {};
}
}
